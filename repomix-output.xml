This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.gitignore
code.ts
manifest.json
package.json
README.md
tsconfig.json
ui.html
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# Node
*.log
*.log.*
node_modules

out/
dist/
code.js
</file>

<file path="code.ts">
// M3 Style to Variable - Versão Otimizada para Material 3 Design Kit

// Configuração do mapeamento
const STYLE_PREFIX = "m3/sys/light/";
const VARIABLE_PREFIX = "M3/Schemes/";

// Função de conversão simples e direta
function convertStyleNameToVariableName(styleName: string): string {
  if (!styleName.startsWith(STYLE_PREFIX)) {
    return "";
  }
  
  // Remove o prefixo e converte o formato
  const token = styleName.slice(STYLE_PREFIX.length);
  const variableName = token
    .split('-')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
  
  return `${VARIABLE_PREFIX}${variableName}`;
}

// Cache para variables (evita múltiplas buscas)
let variableCache: Map<string, Variable> | null = null;

async function getVariableCache(): Promise<Map<string, Variable>> {
  if (!variableCache) {
    variableCache = new Map();
    const allVariables = await figma.variables.getLocalVariablesAsync();
    
    allVariables
      .filter(v => v.resolvedType === 'COLOR' && v.name.startsWith(VARIABLE_PREFIX))
      .forEach(v => variableCache!.set(v.name, v));
  }
  
  return variableCache;
}

// Contador de styles para o UI
async function countColorStyles(selection: readonly SceneNode[]): Promise<number> {
  let count = 0;
  
  function countInNode(node: SceneNode) {
    if ('fillStyleId' in node && node.fillStyleId && typeof node.fillStyleId === 'string') {
      const style = figma.getStyleById(node.fillStyleId);
      if (style?.type === 'PAINT' && style.name.startsWith(STYLE_PREFIX)) {
        count++;
      }
    }
    
    if ('strokeStyleId' in node && node.strokeStyleId && typeof node.strokeStyleId === 'string') {
      const style = figma.getStyleById(node.strokeStyleId);
      if (style?.type === 'PAINT' && style.name.startsWith(STYLE_PREFIX)) {
        count++;
      }
    }
    
    if ('children' in node) {
      node.children.forEach(countInNode);
    }
  }
  
  selection.forEach(countInNode);
  return count;
}

// Função principal de conversão
async function convertStylesToVariables(selection: readonly SceneNode[]): Promise<{
  converted: number;
  failed: number;
  errors: string[];
}> {
  const variables = await getVariableCache();
  const result = {
    converted: 0,
    failed: 0,
    errors: [] as string[]
  };
  
  function processNode(node: SceneNode) {
    // Processar fills
    if ('fillStyleId' in node && node.fillStyleId && typeof node.fillStyleId === 'string') {
      const style = figma.getStyleById(node.fillStyleId);
      
      if (style?.type === 'PAINT' && style.name.startsWith(STYLE_PREFIX)) {
        const variableName = convertStyleNameToVariableName(style.name);
        const variable = variables.get(variableName);
        
        if (variable) {
          try {
            const fills = JSON.parse(JSON.stringify(node.fills));
            if (fills.length > 0) {
              fills[0] = figma.variables.setBoundVariableForPaint(
                fills[0],
                'color',
                variable
              );
              node.fills = fills;
              result.converted++;
            }
          } catch (e) {
            result.failed++;
            result.errors.push(`Failed to convert fill: ${style.name}`);
          }
        } else {
          result.failed++;
          if (!result.errors.includes(variableName)) {
            result.errors.push(`Variable not found: ${variableName}`);
          }
        }
      }
    }
    
    // Processar strokes
    if ('strokeStyleId' in node && node.strokeStyleId && typeof node.strokeStyleId === 'string') {
      const style = figma.getStyleById(node.strokeStyleId);
      
      if (style?.type === 'PAINT' && style.name.startsWith(STYLE_PREFIX)) {
        const variableName = convertStyleNameToVariableName(style.name);
        const variable = variables.get(variableName);
        
        if (variable) {
          try {
            const strokes = JSON.parse(JSON.stringify(node.strokes));
            if (strokes.length > 0) {
              strokes[0] = figma.variables.setBoundVariableForPaint(
                strokes[0],
                'color',
                variable
              );
              node.strokes = strokes;
              result.converted++;
            }
          } catch (e) {
            result.failed++;
            result.errors.push(`Failed to convert stroke: ${style.name}`);
          }
        } else {
          result.failed++;
          if (!result.errors.includes(variableName)) {
            result.errors.push(`Variable not found: ${variableName}`);
          }
        }
      }
    }
    
    // Processar filhos
    if ('children' in node) {
      node.children.forEach(processNode);
    }
  }
  
  selection.forEach(processNode);
  return result;
}

// Mensagens do plugin
figma.ui.onmessage = async (msg) => {
  if (msg.type === 'check-selection') {
    const selection = figma.currentPage.selection;
    const count = await countColorStyles(selection);
    
    figma.ui.postMessage({
      type: 'selection-update',
      count: count,
      hasSelection: selection.length > 0
    });
  }
  
  if (msg.type === 'convert') {
    const selection = figma.currentPage.selection;
    
    if (selection.length === 0) {
      figma.ui.postMessage({
        type: 'error',
        message: 'No elements selected'
      });
      return;
    }
    
    const result = await convertStylesToVariables(selection);
    
    // Enviar resultado para UI
    figma.ui.postMessage({
      type: 'conversion-complete',
      ...result
    });
    
    // Notificação do Figma
    if (result.failed === 0) {
      figma.notify(`✅ Successfully converted ${result.converted} color styles`);
    } else {
      figma.notify(`Converted: ${result.converted} | Failed: ${result.failed}`, {
        timeout: 5000
      });
    }
  }
  
  if (msg.type === 'close') {
    figma.closePlugin();
  }
};

// UI HTML
figma.showUI(__html__, {
  width: 300,
  height: 250,
  title: "M3 Style to Variable"
});
</file>

<file path="manifest.json">
{
  "name": "M3 Style to Variable",
  "id": "1522385565785646661",
  "api": "1.0.0",
  "main": "code.js",
  "capabilities": [],
  "enableProposedApi": false,
  "documentAccess": "dynamic-page",
  "editorType": [
    "figma"
  ],
  "ui": "ui.html",
  "networkAccess": {
    "allowedDomains": [
      "none"
    ]
  }
}
</file>

<file path="package.json">
{
  "name": "m3-style-to-variable",
  "version": "1.0.0",
  "description": "Your Figma Plugin",
  "main": "code.js",
  "scripts": {
    "build": "tsc -p tsconfig.json",
    "lint": "eslint --ext .ts,.tsx --ignore-pattern node_modules .",
    "lint:fix": "eslint --ext .ts,.tsx --ignore-pattern node_modules --fix .",
    "watch": "npm run build -- --watch"
  },
  "author": "",
  "license": "",
  "devDependencies": {
    "@figma/eslint-plugin-figma-plugins": "*",
    "@figma/plugin-typings": "*",
    "@typescript-eslint/eslint-plugin": "^6.12.0",
    "@typescript-eslint/parser": "^6.12.0",
    "eslint": "^8.54.0",
    "typescript": "^5.3.2"
  },
  "eslintConfig": {
    "extends": [
      "eslint:recommended",
      "plugin:@typescript-eslint/recommended",
      "plugin:@figma/figma-plugins/recommended"
    ],
    "parser": "@typescript-eslint/parser",
    "parserOptions": {
      "project": "./tsconfig.json"
    },
    "root": true,
    "rules": {
      "@typescript-eslint/no-unused-vars": [
        "error",
        {
          "argsIgnorePattern": "^_",
          "varsIgnorePattern": "^_",
          "caughtErrorsIgnorePattern": "^_"
        }
      ]
    }
  }
}
</file>

<file path="README.md">
Below are the steps to get your plugin running. You can also find instructions at:

  https://www.figma.com/plugin-docs/plugin-quickstart-guide/

This plugin template uses Typescript and NPM, two standard tools in creating JavaScript applications.

First, download Node.js which comes with NPM. This will allow you to install TypeScript and other
libraries. You can find the download link here:

  https://nodejs.org/en/download/

Next, install TypeScript using the command:

  npm install -g typescript

Finally, in the directory of your plugin, get the latest type definitions for the plugin API by running:

  npm install --save-dev @figma/plugin-typings

If you are familiar with JavaScript, TypeScript will look very familiar. In fact, valid JavaScript code
is already valid Typescript code.

TypeScript adds type annotations to variables. This allows code editors such as Visual Studio Code
to provide information about the Figma API while you are writing code, as well as help catch bugs
you previously didn't notice.

For more information, visit https://www.typescriptlang.org/

Using TypeScript requires a compiler to convert TypeScript (code.ts) into JavaScript (code.js)
for the browser to run.

We recommend writing TypeScript code using Visual Studio code:

1. Download Visual Studio Code if you haven't already: https://code.visualstudio.com/.
2. Open this directory in Visual Studio Code.
3. Compile TypeScript to JavaScript: Run the "Terminal > Run Build Task..." menu item,
    then select "npm: watch". You will have to do this again every time
    you reopen Visual Studio Code.

That's it! Visual Studio Code will regenerate the JavaScript file every time you save.
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "es2016",
    "lib": ["es2016"],
    "strict": true,
    "skipLibCheck": true,
    "typeRoots": [
      "./node_modules/@types",
      "./node_modules/@figma"
    ]
  }
}
</file>

<file path="ui.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>M3 Style to Variable</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      font-size: 14px;
      color: #333;
      background: #fff;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* Header */
    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      border-bottom: 1px solid #e5e5e5;
    }

    .header h1 {
      font-size: 16px;
      font-weight: 600;
      color: #000;
    }

    .close-button {
      background: none;
      border: none;
      cursor: pointer;
      padding: 4px;
      color: #999;
      transition: color 0.2s;
    }

    .close-button:hover {
      color: #333;
    }

    /* Content */
    .content {
      flex: 1;
      padding: 16px;
      display: flex;
      flex-direction: column;
    }

    .description {
      font-size: 14px;
      color: #666;
      margin-bottom: 24px;
    }

    /* Status Box */
    .status-container {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .status-box {
      width: 100%;
      padding: 12px 16px;
      border-radius: 6px;
      text-align: center;
      font-weight: 500;
      transition: all 0.2s;
    }

    .status-box.default {
      background: #f5f5f5;
      color: #666;
    }

    .status-box.ready {
      background: #dcfce7;
      color: #166534;
      border: 1px solid #bbf7d0;
    }

    .status-box.converting {
      background: #e0e7ff;
      color: #3730a3;
      border: 1px solid #c7d2fe;
    }

    /* Button */
    .button-container {
      margin-top: auto;
    }

    .button {
      width: 100%;
      padding: 10px 16px;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      border: none;
    }

    .button.primary {
      background: #000;
      color: #fff;
    }

    .button.primary:hover:not(:disabled) {
      background: #333;
    }

    .button.secondary {
      background: #f5f5f5;
      color: #333;
    }

    .button.secondary:hover:not(:disabled) {
      background: #e5e5e5;
    }

    .button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Loading spinner */
    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .spinner {
      display: inline-block;
      width: 14px;
      height: 14px;
      border: 2px solid #fff;
      border-radius: 50%;
      border-top-color: transparent;
      animation: spin 0.6s linear infinite;
      margin-right: 8px;
      vertical-align: middle;
    }
  </style>
</head>
<body>
 <!-- Content -->
  <div class="content">
    <p class="description">
      Convert Material 3 color styles to their matching variables
    </p>

    <div class="status-container">
      <div class="status-box default" id="statusBox">
        Please select at least one element
      </div>
    </div>

    <div class="button-container">
      <button class="button secondary" id="actionButton" disabled>
        Select Elements
      </button>
    </div>
  </div>

  <script>
    // Estado do plugin
    let state = {
      selectionState: 'none', // 'none' | 'no-styles' | 'ready'
      styleCount: 0,
      isConverting: false
    };

    // Elementos do DOM
    const statusBox = document.getElementById('statusBox');
    const actionButton = document.getElementById('actionButton');
    const closeButton = document.getElementById('closeButton');

    // Atualizar UI baseado no estado
    function updateUI() {
      // Atualizar texto do status
      let statusText = '';
      let statusClass = 'default';
      
      if (state.isConverting) {
        statusText = 'Converting...';
        statusClass = 'converting';
      } else {
        switch (state.selectionState) {
          case 'none':
            statusText = 'Please select at least one element';
            break;
          case 'no-styles':
            statusText = 'No M3 styles detected';
            break;
          case 'ready':
            statusText = `${state.styleCount} Color Styles detected`;
            statusClass = 'ready';
            break;
        }
      }
      
      statusBox.textContent = statusText;
      statusBox.className = `status-box ${statusClass}`;
      
      // Atualizar botão
      const isDisabled = state.selectionState !== 'ready' || state.isConverting;
      actionButton.disabled = isDisabled;
      
      if (state.isConverting) {
        actionButton.innerHTML = '<span class="spinner"></span>Converting...';
        actionButton.className = 'button primary';
      } else {
        switch (state.selectionState) {
          case 'none':
            actionButton.textContent = 'Select Elements';
            actionButton.className = 'button secondary';
            break;
          case 'no-styles':
            actionButton.textContent = 'Select Elements';
            actionButton.className = 'button secondary';
            break;
          case 'ready':
            actionButton.textContent = 'Convert Selection';
            actionButton.className = 'button primary';
            break;
        }
      }
    }

    // Handler para mensagens do plugin
    window.onmessage = (event) => {
      const msg = event.data.pluginMessage;
      if (!msg) return;
      
      switch (msg.type) {
        case 'selection-update':
          if (!msg.hasSelection) {
            state.selectionState = 'none';
          } else if (msg.count === 0) {
            state.selectionState = 'no-styles';
          } else {
            state.selectionState = 'ready';
          }
          state.styleCount = msg.count;
          state.isConverting = false;
          updateUI();
          break;
          
        case 'converting':
          state.isConverting = true;
          updateUI();
          break;
          
        case 'conversion-complete':
          state.isConverting = false;
          if (msg.failed > 0) {
            console.error('Failed conversions:', msg.errors);
          }
          // Re-verificar seleção após conversão
          setTimeout(() => {
            parent.postMessage({ pluginMessage: { type: 'check-selection' } }, '*');
          }, 500);
          break;
          
        case 'error':
          state.isConverting = false;
          console.error(msg.message);
          updateUI();
          break;
      }
    };

    // Event listeners
    actionButton.addEventListener('click', () => {
      if (!actionButton.disabled) {
        parent.postMessage({ pluginMessage: { type: 'convert' } }, '*');
      }
    });

    closeButton.addEventListener('click', () => {
      parent.postMessage({ pluginMessage: { type: 'close' } }, '*');
    });

    // Verificar seleção inicial
    parent.postMessage({ pluginMessage: { type: 'check-selection' } }, '*');
  </script>
</body>
</html>
</file>

</files>
